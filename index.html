<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#080b12" />
  <meta name="color-scheme" content="dark" />
  <title>Mission Control — Workboard</title>
  <style>
    :root {
      --bg: #080b12;
      --bg-2: #101726;
      --card: #121d31;
      --line: #263650;
      --line-soft: #1d2a42;
      --text: #ecf1ff;
      --muted: #9cafce;
      --accent: #73b8ff;
      --ok: #71e7ad;
      --warn: #ffd57d;
      --danger: #ff8baa;
      --radius: 14px;
      --shadow: 0 12px 28px rgba(0, 0, 0, 0.24);
    }

    * { box-sizing: border-box; }

    html { color-scheme: dark; }

    .skip-link {
      position: absolute;
      left: 10px;
      top: -44px;
      background: #0f2444;
      color: #e6f1ff;
      border: 1px solid #78b8ff;
      border-radius: 8px;
      padding: 8px 10px;
      text-decoration: none;
      z-index: 1000;
    }
    .skip-link:focus-visible { top: 10px; }
    body {
      margin: 0;
      color: var(--text);
      font: 14px/1.45 Inter, ui-sans-serif, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(900px 500px at 0% -15%, #21487f66, transparent 60%),
        radial-gradient(700px 420px at 110% -10%, #6939b255, transparent 65%),
        var(--bg);
    }

    .wrap { max-width: 1380px; margin: 18px auto 26px; padding: 0 14px; display: grid; gap: 14px; }

    .card {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--card), var(--bg-2));
      box-shadow: var(--shadow);
    }

    .topbar {
      padding: 14px;
      display: grid;
      gap: 10px;
      position: sticky;
      top: 10px;
      z-index: 30;
      backdrop-filter: blur(6px);
    }
    .title { display: flex; gap: 10px; align-items: baseline; flex-wrap: wrap; }
    h1 { margin: 0; font-size: clamp(22px, 4vw, 34px); }
    .sub { margin: 0; color: var(--muted); }
    .orientation-line {
      margin: 2px 0 0;
      font-size: 12px;
      color: #d9e9ff;
    }

    .stats, .actions { display: flex; gap: 8px; flex-wrap: wrap; }

    .action-notice {
      min-height: 20px;
      font-size: 12px;
      color: var(--muted);
      padding: 2px 2px 0;
    }
    .action-notice[data-level="ok"] { color: var(--ok); }
    .action-notice[data-level="warn"] { color: var(--warn); }
    .action-notice[data-level="info"] { color: #b7d8ff; }

    .ia-map {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }
    .ia-step {
      border: 1px solid #36507a;
      background: #11213a;
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 4px;
      align-content: start;
      min-height: 74px;
    }
    .ia-step strong { font-size: 12px; letter-spacing: .02em; }
    .ia-step .k {
      width: 20px;
      height: 20px;
      border-radius: 999px;
      border: 1px solid #6db3ff;
      color: #cfe6ff;
      font-size: 11px;
      display: grid;
      place-items: center;
    }

    .quick-nav {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .quick-nav a {
      text-decoration: none;
      color: #d8e6ff;
      border: 1px solid #39567f;
      background: #11223c;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
    }
    .quick-nav a:hover { border-color: #83c4ff; }
    .quick-nav a.active {
      border-color: #9dd2ff;
      background: #18345c;
      color: #f1f7ff;
      box-shadow: 0 0 0 1px #9dd2ff33 inset;
    }

    .start-strip {
      border: 1px solid #38557f;
      background: #11233f;
      border-radius: 10px;
      padding: 9px 10px;
      display: grid;
      gap: 7px;
    }
    .start-strip strong {
      font-size: 12px;
      letter-spacing: .03em;
      text-transform: uppercase;
      color: #d9e9ff;
    }
    .start-reason {
      font-size: 12px;
      color: #cfe1ff;
    }
    .start-plan {
      font-size: 12px;
      color: #cfe4ff;
      border-left: 2px solid #4f79aa;
      padding-left: 8px;
    }
    .start-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .path-strip {
      border: 1px solid #355078;
      background: #11233f;
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 6px;
    }
    .path-title {
      font-size: 11px;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: #cfe4ff;
    }
    .path-items {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .path-item {
      border: 1px solid #3f5f8b;
      background: #172b49;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 11px;
      color: #e1edff;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }
    .path-item:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .command-strip {
      border: 1px solid #3b5b86;
      background: #132746;
      border-radius: 10px;
      padding: 8px 10px;
      display: grid;
      gap: 5px;
    }
    .command-label {
      font-size: 11px;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: #cfe4ff;
    }
    .command-text {
      font-size: 12px;
      color: #e7f0ff;
    }

    .context-strip {
      border: 1px solid #36557f;
      background: #11223e;
      border-radius: 10px;
      padding: 8px 10px;
      display: grid;
      gap: 5px;
    }
    .context-label {
      font-size: 11px;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: #cfe4ff;
    }
    .context-text {
      font-size: 12px;
      color: #e6f1ff;
    }

    .freshness-strip {
      border: 1px solid #35527a;
      background: #11213a;
      border-radius: 10px;
      padding: 8px 10px;
      display: grid;
      gap: 4px;
    }
    .freshness-label {
      font-size: 11px;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: #cfe4ff;
    }
    .freshness-text {
      font-size: 12px;
      color: #e6f1ff;
    }

    .quick-nav a:focus-visible,
    .btn:focus-visible,
    .task:focus-visible,
    input:focus-visible,
    textarea:focus-visible,
    select:focus-visible {
      outline: 2px solid #9fd2ff;
      outline-offset: 2px;
      box-shadow: 0 0 0 2px #9fd2ff33;
    }
    .pill {
      border: 1px solid #3b5275;
      background: #172742;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: #d8e6ff;
    }
    .phase-pill {
      border: 1px solid #3b5379;
      background: #152845;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: #dceaff;
      letter-spacing: .02em;
      font-weight: 600;
    }
    .phase-pill[data-phase="blocked"] { border-color: #8a5a34; background: #3a2919; color: #ffe7c6; }
    .phase-pill[data-phase="executing"] { border-color: #2f6a55; background: #18352c; color: #d7ffeb; }
    .phase-pill[data-phase="ready"] { border-color: #496c93; background: #1a2f4d; color: #deebff; }
    .phase-pill[data-phase="setup"] { border-color: #3b5379; background: #152845; color: #dceaff; }
    .pill.now { border-color: #3b74a6; background: #163257; color: #d9ecff; }
    .pill.next { border-color: #496c93; background: #1a2f4d; color: #deebff; }
    .pill.blocked { border-color: #8a5a34; background: #3a2919; color: #ffe7c6; }
    .pill.done { border-color: #2f6a55; background: #18352c; color: #d7ffeb; }

    .health-strip {
      border: 1px solid #35517a;
      background: #12233f;
      border-radius: 10px;
      padding: 7px 10px;
      font-size: 12px;
      color: #dceaff;
    }
    .health-strip[data-level="ok"] { border-color: #2f6a55; color: #d7ffeb; }
    .health-strip[data-level="warn"] { border-color: #8a5a34; color: #ffe7c6; }
    .health-strip[data-level="info"] { border-color: #35517a; color: #dceaff; }

    .tldr-strip {
      border: 1px solid #3b5a85;
      background: #132743;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      color: #e4eeff;
    }

    .shortcut-strip {
      border: 1px solid #355078;
      background: #11223c;
      border-radius: 10px;
      padding: 7px 10px;
      font-size: 12px;
      color: #dbeaff;
    }

    .progress-strip {
      border: 1px solid #36527a;
      background: #122540;
      border-radius: 10px;
      padding: 7px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .progress-chip {
      border: 1px solid #3f5d87;
      background: #1a2f4d;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 11px;
      color: #dbe8ff;
    }
    .progress-chip.active { border-color: #83c4ff; color: #f0f7ff; }
    .progress-chip.done { border-color: #2f6a55; color: #d7ffeb; background: #18352c; }

    .btn {
      border: 1px solid #3b5782;
      background: #172a4b;
      color: var(--text);
      border-radius: 10px;
      padding: 7px 10px;
      font-size: 12px;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: rgba(115, 184, 255, 0.25);
    }
    .btn:hover { border-color: #83c4ff; }
    .btn:disabled {
      cursor: not-allowed;
      opacity: 0.55;
      border-color: #334b6d;
    }
    .btn.primary { background: #1f4675; border-color: #83c4ff; }
    .btn.warn { background: #4f3a1d; border-color: #9c6d1d; }

    .layout { display: grid; gap: 14px; grid-template-columns: 1.45fr .95fr; }

    .board-wrap { padding: 12px; }
    .board-head { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; gap: 8px; flex-wrap: wrap; }
    .board-head-meta { display: grid; gap: 4px; }
    h2, h3 { margin: 0; font-size: 13px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }

    .lane-guide {
      border: 1px solid #334c73;
      background: #10203a;
      border-radius: 10px;
      padding: 8px;
      margin-bottom: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .lane-guide span {
      border: 1px solid #405d87;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 11px;
      color: #d9e7ff;
      background: #162946;
      white-space: nowrap;
    }

    .board { display: grid; gap: 10px; grid-template-columns: repeat(4, minmax(0, 1fr)); }
    .lane {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: linear-gradient(180deg, #10203a, #0d182e);
      min-height: 180px;
      padding: 8px;
      display: grid;
      align-content: start;
      gap: 8px;
      transition: box-shadow 180ms ease, border-color 180ms ease, transform 180ms ease;
    }
    .lane h4 {
      margin: 0;
      font-size: 12px;
      letter-spacing: .05em;
      text-transform: uppercase;
      color: #c8dcff;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .lane h4::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #7ba5d8;
      box-shadow: 0 0 0 2px #7ba5d833;
    }
    .lane[data-lane="now"] { border-color: #366a8f; background: linear-gradient(180deg, #10263f, #0e1e33); }
    .lane[data-lane="now"] h4::before { background: #73b8ff; box-shadow: 0 0 0 2px #73b8ff33; }

    .lane[data-lane="next"] { border-color: #42698f; background: linear-gradient(180deg, #12243c, #0f1c31); }
    .lane[data-lane="next"] h4::before { background: #8fc5ff; box-shadow: 0 0 0 2px #8fc5ff33; }

    .lane[data-lane="blocked"] { border-color: #8a5a34; background: linear-gradient(180deg, #2a2016, #21190f); }
    .lane[data-lane="blocked"] h4::before { background: #ffbf6f; box-shadow: 0 0 0 2px #ffbf6f33; }

    .lane[data-lane="done"] { border-color: #2f6a55; background: linear-gradient(180deg, #142a24, #10221d); }
    .lane[data-lane="done"] h4::before { background: #71e7ad; box-shadow: 0 0 0 2px #71e7ad33; }

    .lane.flash {
      border-color: #88c7ff;
      box-shadow: 0 0 0 2px #88c7ff66 inset, 0 10px 18px rgba(10, 21, 37, 0.45);
      transform: translateY(-1px);
    }

    .task {
      border: 1px solid #2a4063;
      background: #15253f;
      border-radius: 9px;
      padding: 8px;
      cursor: pointer;
      display: grid;
      gap: 4px;
    }
    .task:hover { border-color: #7ebaff; }
    .task.active { border-color: #9ed0ff; box-shadow: 0 0 0 1px #9ed0ff44 inset; }
    .task-title { font-weight: 600; font-size: 13px; }
    .task-meta { font-size: 12px; color: var(--muted); display: flex; justify-content: space-between; gap: 8px; }

    .panel { padding: 12px; display: grid; gap: 12px; align-content: start; }
    .panel-section { border: 1px solid var(--line-soft); border-radius: 10px; padding: 10px; background: #101c32; display: grid; gap: 8px; box-shadow: inset 0 1px 0 rgba(255,255,255,.03); }
    .panel-section[data-section="task"] { border-left: 3px solid #4da8ff; }
    .panel-section[data-section="brief"] { border-left: 3px solid #8dc6ff; }
    .panel-section[data-section="validation"] { border-left: 3px solid #7fb2ff; }
    .panel-section[data-section="heartbeat"] { border-left: 3px solid #6ca4ff; }
    .panel-section[data-section="strike"] { border-left: 3px solid #9e88ff; }
    .panel-section[data-section="updates"] { border-left: 3px solid #58c6b3; }

    label { font-size: 12px; color: #c4d9ff; display: grid; gap: 4px; }
    input, textarea, select {
      width: 100%;
      border: 1px solid #39557e;
      border-radius: 8px;
      background: #0d1930;
      color: var(--text);
      padding: 8px;
      font: inherit;
    }
    textarea { min-height: 84px; resize: vertical; }

    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .danger { color: #ffd9e4; background: #3a2230; border-color: #7a4c63; }
    .ok { color: #d8ffe9; background: #18362f; border-color: #2d6d57; }
    .muted { color: var(--muted); }

    .prompt-box {
      white-space: pre-wrap;
      border: 1px solid #35527b;
      border-radius: 8px;
      background: #0f1d35;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
      min-height: 150px;
    }

    .checklist { display: grid; gap: 6px; font-size: 13px; }
    .checklist label { display: flex; gap: 8px; align-items: center; }

    .feed { display: grid; gap: 7px; max-height: 220px; overflow: auto; }
    .feed-item { border: 1px solid #2b4065; border-radius: 8px; padding: 8px; background: #14243f; }
    .feed-item .meta { color: var(--muted); font-size: 12px; }

    .strike-list { margin: 0; padding-left: 18px; display: grid; gap: 4px; }
    .strike-list li { color: #dbe8ff; }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #01040acc;
      padding: 14px;
      overscroll-behavior: contain;
    }
    .modal.show { display: flex; }
    .modal-card { width: min(560px, 100%); }

    .empty { color: var(--muted); font-size: 13px; border: 1px dashed #2f4364; border-radius: 8px; padding: 9px; }

    #workboardSection,
    #taskPanelSection,
    #strikeDeskSection,
    #updatesSection { scroll-margin-top: 16px; }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0ms !important;
        transition-duration: 0ms !important;
        scroll-behavior: auto !important;
      }
    }

    @media (max-width: 1120px) {
      .layout { grid-template-columns: 1fr; }
      .board { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .ia-map { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    @media (max-width: 680px) {
      .board { grid-template-columns: 1fr; }
      .ia-map { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <a href="#workboardSection" class="skip-link">Skip to Workboard</a>
  <main class="wrap" id="mainContent">
    <section class="card topbar">
      <div class="title">
        <h1 id="heroTitle">Mission Control</h1>
        <span class="phase-pill" id="phasePill" data-phase="setup">Setup</span>
        <span class="pill" id="clock">--:--</span>
      </div>
      <p class="sub" id="heroSub">Loading workspace…</p>
      <p class="orientation-line" id="objectiveLine">Objective: determining top execution objective…</p>
      <p class="orientation-line" id="orientationLine">Loading orientation…</p>
      <div class="ia-map" aria-label="10-second workflow map">
        <div class="ia-step">
          <span class="k">1</span>
          <strong>Scan lanes</strong>
          <span class="muted" id="iaNow">Pick the top Now task.</span>
        </div>
        <div class="ia-step">
          <span class="k">2</span>
          <strong>Edit task</strong>
          <span class="muted">Click a card to open Task details.</span>
        </div>
        <div class="ia-step">
          <span class="k">3</span>
          <strong>Move flow</strong>
          <span class="muted" id="iaBlocker">Clear blockers before pulling Next.</span>
        </div>
        <div class="ia-step">
          <span class="k">4</span>
          <strong>Share brief</strong>
          <span class="muted">Copy execution brief and run.</span>
        </div>
      </div>
      <nav class="quick-nav" aria-label="Mission Control quick navigation">
        <a id="navWorkboard" href="#workboardSection">1) Workboard</a>
        <a id="navTaskDetails" href="#taskPanelSection">2) Task details</a>
        <a id="navStrikeDesk" href="#strikeDeskSection">3) Strike desk</a>
        <a id="navUpdates" href="#updatesSection">4) Recent updates</a>
      </nav>
      <div class="orientation-line" id="whereAmI">You are in Step 1 of 4: Workboard.</div>
      <div class="muted" id="stepGoalLine">Goal: pick the top task and move execution forward.</div>
      <div class="muted" id="stepActionLine">Action: scan top lane and choose one task.</div>
      <div class="muted" id="atAGlanceLine">At a glance: assessing board state…</div>
      <div class="muted" id="stepProgressLine">Workflow progress: Step 1/4 (25%).</div>
      <button class="btn" id="nextStepBtn">Next step: Task details</button>
      <section class="start-strip" aria-label="Mission Control start here">
        <strong>Start here</strong>
        <span class="muted" id="startCue">Loading top action…</span>
        <span class="start-reason" id="startReason">Reason: prioritizing critical path.</span>
        <span class="start-plan" id="startPlan">Then: move flow and copy execution brief.</span>
        <button class="btn primary" id="recommendedActionBtn">Run recommended step</button>
        <div class="start-actions">
          <button class="btn primary" id="focusFirstActionBtn">Open first action</button>
          <button class="btn" id="focusNowBtn">Focus top Now</button>
          <button class="btn" id="focusBlockedBtn">Focus top Blocked</button>
          <button class="btn" id="focusNextBtn">Focus top Next</button>
        </div>
      </section>
      <section class="path-strip" aria-label="10-second mission path">
        <span class="path-title">Mission path</span>
        <div class="path-items">
          <button class="path-item" id="pathNowBtn">Now: —</button>
          <button class="path-item" id="pathBlockedBtn">Blocked: —</button>
          <button class="path-item" id="pathNextBtn">Next: —</button>
        </div>
      </section>
      <section class="command-strip" aria-label="Immediate command">
        <span class="command-label">Immediate command</span>
        <span class="command-text" id="missionCommand">Open top task, move flow, copy brief.</span>
      </section>
      <section class="context-strip" aria-label="Current context">
        <span class="context-label">Current context</span>
        <span class="context-text" id="contextTrail">Workboard › No task selected</span>
        <button class="btn" id="openSelectedTaskBtn" aria-disabled="true" disabled>Open selected task details</button>
      </section>
      <section class="freshness-strip" aria-label="Board freshness">
        <span class="freshness-label">Board freshness</span>
        <span class="freshness-text" id="freshnessLine">No updates logged yet.</span>
      </section>
      <div class="stats" id="stats"></div>
      <div class="health-strip" id="healthSignal" data-level="info">Status: assessing board…</div>
      <div class="tldr-strip" id="tldrLine">TL;DR: assessing next best action…</div>
      <div class="shortcut-strip" id="shortcutLine">Shortcuts: [N] add task · [F] open first action · [C] copy brief</div>
      <section class="progress-strip" aria-label="Execution progress">
        <span class="progress-chip" id="progressStep1">Step 1: choose action</span>
        <span class="progress-chip" id="progressStep2">Step 2: execute flow</span>
        <span class="progress-chip" id="progressStep3">Step 3: share brief</span>
      </section>
      <div class="action-notice" id="progressHint" data-level="info" aria-live="polite">Tip: Start with Step 1 button above.</div>
      <div class="actions">
        <button class="btn primary" id="addTaskBtn">1) Add task</button>
        <button class="btn" id="copyPromptBtn">2) Copy brief</button>
        <button class="btn" id="exportBtn">3) Export JSON</button>
        <button class="btn" id="importBtn">4) Import JSON</button>
        <button class="btn warn" id="resetBtn">5) Reset baseline</button>
      </div>
      <div class="action-notice" id="actionNotice" data-level="info" aria-live="polite">Ready.</div>
      <input id="importInput" type="file" accept="application/json" style="display:none" />
    </section>

    <section class="layout">
      <article class="card board-wrap" id="workboardSection">
        <div class="board-head">
          <div class="board-head-meta">
            <h2>1. Workboard</h2>
            <span class="muted" id="boardPurposeLine">Purpose: pick the top item and move it across lanes to keep execution flowing.</span>
            <span class="muted" id="boardMeta">No task selected</span>
          </div>
          <div class="row">
            <button class="btn" id="pullNextBtn">Pull top Next → Now</button>
            <button class="btn" id="unblockTopBtn">Unblock top Blocked → Next</button>
            <button class="btn ok" id="completeTopNowBtn">Complete top Now → Done</button>
          </div>
        </div>
        <div class="lane-guide" id="laneGuide" aria-label="Lane guide">
          <span>Now = executing this cycle</span>
          <span>Next = ready queue</span>
          <span>Blocked = needs unblock action</span>
          <span>Done = shipped + verified</span>
        </div>
        <div class="board" id="board"></div>
      </article>

      <aside class="card panel" id="taskPanelSection">
        <section class="panel-section" data-section="task">
          <h3>2. Task details</h3>
          <div class="muted" id="taskPurposeLine">Purpose: update selected task details, owner, and status before saving.</div>
          <div class="muted" id="taskContextLine">Context: no task selected.</div>
          <div id="taskEmpty" class="empty">Select a task card to edit details and move status.</div>
          <div id="taskEditor" style="display:none; gap:8px;">
            <label>Title<input id="taskTitle" name="taskTitle" autocomplete="off" /></label>
            <label>Description<textarea id="taskDescription" name="taskDescription" autocomplete="off" placeholder="Describe the task…"></textarea></label>
            <div class="row">
              <label style="flex:1">Status
                <select id="taskStatus" name="taskStatus" autocomplete="off">
                  <option value="now">Now</option>
                  <option value="next">Next</option>
                  <option value="blocked">Blocked</option>
                  <option value="done">Done</option>
                </select>
              </label>
              <label style="flex:1">Priority (1 = highest)<input id="taskPriority" name="taskPriority" type="number" min="1" max="99" inputmode="numeric" autocomplete="off" /></label>
            </div>
            <label>Link (optional)<input id="taskLink" name="taskLink" type="url" autocomplete="off" placeholder="https://example.com/…" /></label>
            <label>Owner<input id="taskOwner" name="taskOwner" autocomplete="off" placeholder="Owner name…" /></label>
            <label>Definition of done<textarea id="taskDoD" name="taskDoD" autocomplete="off" placeholder="One checklist item per line…"></textarea></label>
            <div class="row">
              <button class="btn ok" id="saveTaskBtn">Save task</button>
              <button class="btn" id="openTaskLinkBtn">Open link</button>
              <button class="btn danger" id="deleteTaskBtn">Delete</button>
            </div>
            <div class="row">
              <button class="btn" id="moveNowBtn">Move to Now</button>
              <button class="btn" id="moveNextBtn">Move to Next</button>
              <button class="btn warn" id="moveBlockedBtn">Move to Blocked</button>
              <button class="btn ok" id="moveDoneBtn">Move to Done</button>
            </div>
          </div>
        </section>

        <section class="panel-section" data-section="brief">
          <h3>Execution brief</h3>
          <div class="prompt-box" id="prompt"></div>
        </section>

        <section class="panel-section" data-section="validation">
          <h3>Validation criteria</h3>
          <div class="checklist" id="criteria"></div>
        </section>

        <section class="panel-section" data-section="heartbeat">
          <h3>Heartbeat loop</h3>
          <div class="muted" id="heartbeatSummary">No loop status yet.</div>
        </section>

        <section class="panel-section" id="strikeDeskSection" data-section="strike">
          <h3>3. Strike desk</h3>
          <div class="muted" id="strikePurposeLine">Purpose: capture Strike coordination notes and generate a copy-ready Strike brief.</div>
          <div class="muted" id="strikePolicy"></div>
          <div>
            <div class="muted">Today focus</div>
            <ul class="strike-list" id="strikeFocus"></ul>
          </div>
          <div class="row">
            <input id="strikeNoteInput" name="strikeNoteInput" autocomplete="off" placeholder="Add strike note / request…" style="flex:1" />
            <button class="btn" id="strikeNoteAddBtn">Add note</button>
          </div>
          <div class="feed" id="strikeNotes"></div>
          <button class="btn" id="copyStrikeBriefBtn">Copy strike brief</button>
        </section>

        <section class="panel-section" id="updatesSection" data-section="updates">
          <h3>4. Recent updates</h3>
          <div class="muted" id="updatesPurposeLine">Purpose: log progress updates so freshness and execution context stay current.</div>
          <div class="row">
            <input id="feedInput" name="feedInput" autocomplete="off" placeholder="Add a progress note…" style="flex:1" />
            <button class="btn" id="feedAddBtn">Add</button>
          </div>
          <div class="feed" id="feed"></div>
        </section>
      </aside>
    </section>
  </main>

  <div class="modal" id="taskModal" role="dialog" aria-modal="true" aria-labelledby="createTaskTitle">
    <div class="card panel modal-card">
      <h3 id="createTaskTitle">Create task</h3>
      <label>Title<input id="newTaskTitle" name="newTaskTitle" autocomplete="off" /></label>
      <label>Description<textarea id="newTaskDescription" name="newTaskDescription" autocomplete="off" placeholder="Describe the task…"></textarea></label>
      <div class="row">
        <label style="flex:1">Status
          <select id="newTaskStatus" name="newTaskStatus" autocomplete="off">
            <option value="now">Now</option>
            <option value="next">Next</option>
            <option value="blocked">Blocked</option>
            <option value="done">Done</option>
          </select>
        </label>
        <label style="flex:1">Priority<input id="newTaskPriority" name="newTaskPriority" type="number" min="1" max="99" value="5" inputmode="numeric" autocomplete="off" /></label>
      </div>
      <div class="row">
        <button class="btn primary" id="createTaskConfirmBtn">Create</button>
        <button class="btn" id="createTaskCancelBtn">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'mc:state:v3';
    const CRITERIA_STORAGE_KEY = 'mc:criteria:v1';
    const LANES = ['now', 'next', 'blocked', 'done'];
    const LANE_LABEL = { now: 'Now', next: 'Next', blocked: 'Blocked', done: 'Done' };
    const SECTION_ORDER = ['workboardSection', 'taskPanelSection', 'strikeDeskSection', 'updatesSection'];
    const SECTION_NAMES = {
      workboardSection: 'Workboard',
      taskPanelSection: 'Task details',
      strikeDeskSection: 'Strike desk',
      updatesSection: 'Recent updates'
    };
    const SECTION_GOALS = {
      workboardSection: 'Goal: pick the top task and move execution forward.',
      taskPanelSection: 'Goal: edit task details, owner, and status in one pass.',
      strikeDeskSection: 'Goal: capture Strike coordination notes and brief.',
      updatesSection: 'Goal: log latest updates and keep board freshness current.'
    };
    const SECTION_ACTIONS = {
      workboardSection: 'Action: scan top lane and choose one task.',
      taskPanelSection: 'Action: update details, then save or move status.',
      strikeDeskSection: 'Action: capture coordination note and copy Strike brief.',
      updatesSection: 'Action: add fresh update to keep timeline current.'
    };

    const qs = (id) => document.getElementById(id);

    const app = {
      baseline: null,
      state: null,
      selectedTaskId: null,
      actionNoticeTimer: null,
      recommendedAction: null,
      criteriaChecks: {},
      heartbeatChecklist: [
        'Scope stays on making Mission Control genuinely useful for daily execution.',
        'Every clickable control must produce a visible state change.',
        'Execution brief is updated from the real board state.',
        'Top blocker has a concrete next action.',
        'Release only after quick smoke test passes.'
      ]
    };

    function nowClock() {
      qs('clock').textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function createDefaultState(raw = {}) {
      const tasks = Array.isArray(raw.tasks) ? raw.tasks : [];
      return {
        heroTitle: raw.heroTitle || 'Mission Control',
        heroSub: raw.heroSub || 'Execution board',
        validationCriteria: Array.isArray(raw.validationCriteria) ? raw.validationCriteria : [
          'Top priorities are obvious in under 10 seconds.',
          'Every task has owner + next action + definition of done.',
          'Blockers are visible and actionable.',
          'Execution brief can be copied and used immediately.',
          'Board updates persist after refresh.'
        ],
        tasks: tasks.map(normalizeTask),
        feed: Array.isArray(raw.feed) ? raw.feed.slice(0, 30).map(normalizeFeed) : [],
        strikeDesk: normalizeStrikeDesk(raw.strikeDesk || {})
      };
    }

    function normalizeTask(t = {}) {
      return {
        id: t.id || cryptoRandom(),
        title: t.title || t.name || 'Untitled task',
        description: t.description || t.meta || '',
        status: LANES.includes(t.status) ? t.status : 'next',
        priority: Number.isFinite(Number(t.priority)) ? Number(t.priority) : 5,
        owner: t.owner || '',
        link: t.link || '',
        definitionOfDone: Array.isArray(t.definitionOfDone)
          ? t.definitionOfDone
          : String(t.definitionOfDone || '').split('\n').map((s) => s.trim()).filter(Boolean),
      };
    }

    function normalizeFeed(f = {}) {
      return {
        id: f.id || cryptoRandom(),
        text: String(f.text || '').trim() || 'Update',
        time: f.time || new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        ts: Number.isFinite(Number(f.ts)) ? Number(f.ts) : Date.now(),
        level: f.level || 'info'
      };
    }

    function normalizeStrikeDesk(raw = {}) {
      const normalizeList = (arr, fallback = []) => {
        if (!Array.isArray(arr)) return fallback;
        return arr.map((x) => String(x || '').trim()).filter(Boolean).slice(0, 12);
      };

      return {
        policy: String(raw.policy || 'Rule: Mission Control can coordinate Strike, but do not edit Strike product code (frontend/src, backend/src).').trim(),
        focus: normalizeList(raw.focus, [
          'Capture incidents + triage priorities',
          'Draft Claude Code execution prompts for Jul',
          'Prepare daily VC + market brief',
        ]),
        notes: normalizeList(raw.notes, []),
      };
    }

    function cryptoRandom() {
      return Math.random().toString(36).slice(2, 10);
    }

    async function loadBaseline() {
      try {
        const res = await fetch('state.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('State load failed');
        return await res.json();
      } catch {
        return {};
      }
    }

    function loadPersisted() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function persist() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(app.state));
    }

    function loadCriteriaState() {
      try {
        const raw = localStorage.getItem(CRITERIA_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch {
        return {};
      }
    }

    function persistCriteriaState() {
      localStorage.setItem(CRITERIA_STORAGE_KEY, JSON.stringify(app.criteriaChecks || {}));
    }

    function getTaskById(id) {
      return app.state.tasks.find((t) => t.id === id) || null;
    }

    function sortedTasks(status) {
      return app.state.tasks
        .filter((t) => t.status === status)
        .sort((a, b) => a.priority - b.priority || a.title.localeCompare(b.title));
    }

    function getDefaultTaskId() {
      const candidate =
        sortedTasks('now')[0] ||
        sortedTasks('blocked')[0] ||
        sortedTasks('next')[0] ||
        sortedTasks('done')[0] ||
        null;
      return candidate?.id || null;
    }

    function formatAge(ts) {
      const value = Number(ts);
      if (!Number.isFinite(value) || value <= 0) return 'unknown age';
      const diffMs = Math.max(0, Date.now() - value);
      const min = Math.floor(diffMs / 60000);
      if (min < 1) return 'just now';
      if (min < 60) return `${min}m ago`;
      const hrs = Math.floor(min / 60);
      if (hrs < 24) return `${hrs}h ago`;
      const days = Math.floor(hrs / 24);
      return `${days}d ago`;
    }

    function renderBoard() {
      const board = qs('board');
      board.innerHTML = LANES.map((lane) => {
        const tasks = sortedTasks(lane);
        const cards = tasks.length
          ? tasks.map((t) => {
              const active = t.id === app.selectedTaskId ? 'active' : '';
              return `<button class="task ${active}" data-task-id="${escapeHtml(t.id)}">
                <span class="task-title">${escapeHtml(t.title)}</span>
                <span class="task-meta">
                  <span>P${escapeHtml(String(t.priority))}</span>
                  <span>${escapeHtml(t.owner || 'unassigned')}</span>
                </span>
              </button>`;
            }).join('')
          : '<div class="empty">No tasks</div>';
        return `<section class="lane" data-lane="${lane}">
          <h4>${LANE_LABEL[lane]} (${tasks.length})</h4>
          ${cards}
        </section>`;
      }).join('');

      board.querySelectorAll('[data-task-id]').forEach((el) => {
        el.addEventListener('click', () => {
          app.selectedTaskId = el.getAttribute('data-task-id');
          render();
          jumpToTaskDetails();
        });
      });
    }

    function jumpToTaskDetails() {
      const panel = qs('taskPanelSection');
      if (!panel || typeof panel.scrollIntoView !== 'function') return;
      panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function renderStats() {
      const count = Object.fromEntries(LANES.map((lane) => [lane, sortedTasks(lane).length]));
      qs('stats').innerHTML = [
        `<span class="pill now">Now: ${count.now}</span>`,
        `<span class="pill next">Next: ${count.next}</span>`,
        `<span class="pill blocked">Blocked: ${count.blocked}</span>`,
        `<span class="pill done">Done: ${count.done}</span>`,
      ].join('');

      const phasePill = qs('phasePill');
      const phase = count.blocked > 0
        ? 'blocked'
        : count.now > 0
          ? 'executing'
          : count.next > 0
            ? 'ready'
            : 'setup';
      const phaseLabel = phase === 'blocked'
        ? '■ Blocked'
        : phase === 'executing'
          ? '● Executing'
          : phase === 'ready'
            ? '→ Ready'
            : '○ Setup';
      if (phasePill) {
        phasePill.dataset.phase = phase;
        phasePill.textContent = phaseLabel;
      }

      const health = qs('healthSignal');
      if (health) {
        if (count.blocked > 0) {
          health.textContent = `Status: blocked path (${count.blocked}) — clear blockers first.`;
          health.dataset.level = 'warn';
        } else if (count.now > 0) {
          health.textContent = `Status: executing (${count.now} in Now) — finish current lane.`;
          health.dataset.level = 'ok';
        } else if (count.next > 0) {
          health.textContent = `Status: ready queue only (${count.next} in Next) — pull one into Now.`;
          health.dataset.level = 'info';
        } else {
          health.textContent = 'Status: empty board — add first task to begin execution.';
          health.dataset.level = 'warn';
        }
      }

      qs('heroTitle').textContent = app.state.heroTitle;
      qs('heroSub').textContent = app.state.heroSub;
      const selectedTask = app.selectedTaskId ? getTaskById(app.selectedTaskId) : null;
      qs('boardMeta').textContent = selectedTask ? `Editing ${selectedTask.title || 'task'}` : 'No task selected';

      const navWorkboard = qs('navWorkboard');
      if (navWorkboard) navWorkboard.textContent = `1) Workboard (Now ${count.now} • Blocked ${count.blocked})`;
      const selectedTaskLabel = selectedTask?.title
        ? (selectedTask.title.length > 24 ? `${selectedTask.title.slice(0, 23)}…` : selectedTask.title)
        : '';
      const navTaskDetails = qs('navTaskDetails');
      if (navTaskDetails) navTaskDetails.textContent = selectedTask ? `2) Task details (${selectedTaskLabel})` : '2) Task details';
      const navStrikeDesk = qs('navStrikeDesk');
      if (navStrikeDesk) navStrikeDesk.textContent = `3) Strike desk (${(app.state.strikeDesk?.notes || []).length} notes)`;
      const navUpdates = qs('navUpdates');
      if (navUpdates) navUpdates.textContent = `4) Recent updates (${app.state.feed.length})`;

      const contextTrail = qs('contextTrail');
      if (contextTrail) {
        contextTrail.textContent = selectedTask
          ? `Workboard › ${LANE_LABEL[selectedTask.status]} › ${selectedTask.title}`
          : 'Workboard › No task selected';
      }

      const openSelectedTaskBtn = qs('openSelectedTaskBtn');
      if (openSelectedTaskBtn) {
        const hasTask = Boolean(selectedTask);
        openSelectedTaskBtn.disabled = !hasTask;
        openSelectedTaskBtn.setAttribute('aria-disabled', hasTask ? 'false' : 'true');
        openSelectedTaskBtn.textContent = hasTask
          ? `Open selected task details: ${selectedTask.title.length > 28 ? `${selectedTask.title.slice(0, 27)}…` : selectedTask.title}`
          : 'Open selected task details';
      }

      const latestFeed = app.state.feed[app.state.feed.length - 1] || null;
      const freshnessLine = qs('freshnessLine');
      if (freshnessLine) {
        freshnessLine.textContent = latestFeed
          ? `Last update ${formatAge(latestFeed.ts)} (${latestFeed.time}): ${latestFeed.text}`
          : 'No updates logged yet.';
      }

      const topNow = sortedTasks('now')[0];
      const topNext = sortedTasks('next')[0];
      const topBlocked = sortedTasks('blocked')[0];
      const firstAction = topNow || topBlocked || topNext || null;
      const short = (text, max = 28) => (text && text.length > max ? `${text.slice(0, max - 1)}…` : text || '');

      const objectiveLine = qs('objectiveLine');
      if (objectiveLine) {
        objectiveLine.textContent = topBlocked
          ? `Objective: clear blocker ${short(topBlocked.title, 46)} to reopen flow.`
          : topNow
            ? `Objective: complete ${short(topNow.title, 48)} before pulling new work.`
            : topNext
              ? `Objective: promote ${short(topNext.title, 48)} into Now and start execution.`
              : 'Objective: add first task, assign owner, and begin execution.';
      }

      const atAGlanceLine = qs('atAGlanceLine');
      if (atAGlanceLine) {
        atAGlanceLine.textContent = firstAction
          ? `At a glance: Now ${count.now} · Blocked ${count.blocked} · Next ${count.next} · Focus ${short(firstAction.title, 34)}.`
          : `At a glance: board is empty (Now ${count.now} · Blocked ${count.blocked} · Next ${count.next}) — add first task.`;
      }

      const tldrLine = qs('tldrLine');
      if (tldrLine) {
        tldrLine.textContent = topNow
          ? `TL;DR: Finish ${short(topNow.title, 42)} now, then copy execution brief.`
          : topBlocked
            ? `TL;DR: Unblock ${short(topBlocked.title, 40)} first, then pull next work.`
            : topNext
              ? `TL;DR: Pull ${short(topNext.title, 42)} into Now and start execution.`
              : 'TL;DR: Add your first task, assign owner, then execute from Now.';
      }

      const progress1 = qs('progressStep1');
      const progress2 = qs('progressStep2');
      const progress3 = qs('progressStep3');
      const setProgress = (el, state) => {
        if (!el) return;
        el.classList.remove('active', 'done');
        if (state === 'active') el.classList.add('active');
        if (state === 'done') el.classList.add('done');
      };
      const progressHint = qs('progressHint');
      if (!firstAction) {
        setProgress(progress1, 'active');
        setProgress(progress2, '');
        setProgress(progress3, '');
        if (progressHint) progressHint.textContent = 'Tip: Add a task to activate execution flow.';
      } else if (topNow || topBlocked) {
        setProgress(progress1, 'done');
        setProgress(progress2, 'active');
        setProgress(progress3, '');
        if (progressHint) progressHint.textContent = 'Tip: Update/move current task, then copy brief.';
      } else {
        setProgress(progress1, 'done');
        setProgress(progress2, 'done');
        setProgress(progress3, 'active');
        if (progressHint) progressHint.textContent = 'Tip: Copy execution brief to hand off current state.';
      }

      const orientationLine = qs('orientationLine');
      if (orientationLine) {
        orientationLine.textContent = topNow
          ? `Mode: executing • Finish ${short(topNow.title, 44)}.`
          : topBlocked
            ? `Mode: blocked • Clear ${short(topBlocked.title, 42)} first.`
            : topNext
              ? `Mode: ready • Pull ${short(topNext.title, 44)} into Now.`
              : 'Mode: setup • Add first task to begin execution.';
      }

      qs('iaNow').textContent = topNow ? `Start with: ${topNow.title}` : 'No Now task. Promote one from Next.';
      qs('iaBlocker').textContent = topBlocked
        ? `Top blocker: ${topBlocked.title}`
        : 'No blockers. Pull next highest-priority task.';
      qs('startCue').textContent = topNow
        ? `Open “${topNow.title}” in Task details, then save or move.`
        : topBlocked
          ? `No Now task. Clear blocker “${topBlocked.title}” first.`
          : topNext
            ? `No Now task. Promote “${topNext.title}” from Next.`
            : 'Add a task to begin execution flow.';

      const startReason = qs('startReason');
      if (startReason) {
        startReason.textContent = topNow
          ? 'Reason: Now lane is active execution and should be finished before pulling more work.'
          : topBlocked
            ? 'Reason: Blockers are currently the critical path to recover execution flow.'
            : topNext
              ? 'Reason: No active Now task, so highest-priority Next becomes the fastest start.'
              : 'Reason: No tasks exist yet, so creating one is the first actionable step.';
      }

      const startPlan = qs('startPlan');
      if (startPlan) {
        startPlan.textContent = topNow
          ? 'Then: update status (or complete) and copy execution brief.'
          : topBlocked
            ? 'Then: move unblocked work to Next/Now and continue execution.'
            : topNext
              ? 'Then: open task details, assign owner, and execute from Now.'
              : 'Then: add a task, set owner/status, and start with Step 1.';
      }

      const recommendedActionBtn = qs('recommendedActionBtn');
      if (recommendedActionBtn) {
        if (topNow) {
          app.recommendedAction = 'openFirst';
          recommendedActionBtn.textContent = `Step 1: Open ${short(topNow.title, 28)}`;
        } else if (topBlocked) {
          app.recommendedAction = 'unblockTop';
          recommendedActionBtn.textContent = `Step 1: Unblock ${short(topBlocked.title, 26)}`;
        } else if (topNext) {
          app.recommendedAction = 'pullTopNext';
          recommendedActionBtn.textContent = `Step 1: Pull ${short(topNext.title, 28)}`;
        } else {
          app.recommendedAction = 'addTask';
          recommendedActionBtn.textContent = 'Step 1: Add first task';
        }
      }

      const firstActionBtn = qs('focusFirstActionBtn');
      if (firstActionBtn) {
        firstActionBtn.textContent = firstAction ? `Open: ${short(firstAction.title)}` : 'Open first action';
        firstActionBtn.disabled = !firstAction;
        firstActionBtn.setAttribute('aria-disabled', firstAction ? 'false' : 'true');
      }

      const focusNowBtn = qs('focusNowBtn');
      if (focusNowBtn) {
        focusNowBtn.textContent = topNow ? `Focus Now: ${short(topNow.title, 22)}` : 'Focus top Now';
        focusNowBtn.disabled = !topNow;
        focusNowBtn.setAttribute('aria-disabled', topNow ? 'false' : 'true');
      }

      const focusBlockedBtn = qs('focusBlockedBtn');
      if (focusBlockedBtn) {
        focusBlockedBtn.textContent = topBlocked ? `Focus Blocked: ${short(topBlocked.title, 18)}` : 'Focus top Blocked';
        focusBlockedBtn.disabled = !topBlocked;
        focusBlockedBtn.setAttribute('aria-disabled', topBlocked ? 'false' : 'true');
      }

      const focusNextBtn = qs('focusNextBtn');
      if (focusNextBtn) {
        focusNextBtn.textContent = topNext ? `Focus Next: ${short(topNext.title, 20)}` : 'Focus top Next';
        focusNextBtn.disabled = !topNext;
        focusNextBtn.setAttribute('aria-disabled', topNext ? 'false' : 'true');
      }

      const pullBtn = qs('pullNextBtn');
      if (pullBtn) {
        pullBtn.textContent = topNext ? `Pull Next → Now: ${short(topNext.title, 24)}` : 'Pull top Next → Now';
        pullBtn.disabled = !topNext;
        pullBtn.setAttribute('aria-disabled', topNext ? 'false' : 'true');
      }

      const unblockBtn = qs('unblockTopBtn');
      if (unblockBtn) {
        unblockBtn.textContent = topBlocked ? `Unblock → Next: ${short(topBlocked.title, 22)}` : 'Unblock top Blocked → Next';
        unblockBtn.disabled = !topBlocked;
        unblockBtn.setAttribute('aria-disabled', topBlocked ? 'false' : 'true');
      }

      const completeBtn = qs('completeTopNowBtn');
      if (completeBtn) {
        completeBtn.textContent = topNow ? `Complete → Done: ${short(topNow.title, 20)}` : 'Complete top Now → Done';
        completeBtn.disabled = !topNow;
        completeBtn.setAttribute('aria-disabled', topNow ? 'false' : 'true');
      }

      const setPathButton = (id, prefix, task) => {
        const btn = qs(id);
        if (!btn) return;
        btn.textContent = task ? `${prefix}: ${short(task.title, 30)}` : `${prefix}: none`;
        btn.disabled = !task;
        btn.setAttribute('aria-disabled', task ? 'false' : 'true');
        if (task) btn.dataset.taskId = task.id;
        else delete btn.dataset.taskId;
      };
      setPathButton('pathNowBtn', 'Now', topNow);
      setPathButton('pathBlockedBtn', 'Blocked', topBlocked);
      setPathButton('pathNextBtn', 'Next', topNext);

      const command = topNow
        ? `1) Open ${short(topNow.title, 36)}  2) Move or save  3) Copy execution brief`
        : topBlocked
          ? `1) Unblock ${short(topBlocked.title, 34)}  2) Pull next task  3) Copy execution brief`
          : topNext
            ? `1) Pull ${short(topNext.title, 36)} into Now  2) Open details  3) Copy execution brief`
            : '1) Add a task  2) Set status/owner  3) Copy execution brief';
      const missionCommand = qs('missionCommand');
      if (missionCommand) missionCommand.textContent = command;
    }

    function syncOpenLinkButtonFromEditor() {
      const btn = qs('openTaskLinkBtn');
      const editor = qs('taskEditor');
      if (!btn || !editor || editor.style.display !== 'grid') {
        if (btn) {
          btn.textContent = 'Open link';
          btn.disabled = true;
          btn.setAttribute('aria-disabled', 'true');
        }
        return;
      }

      const link = (qs('taskLink')?.value || '').trim();
      const hasLink = Boolean(link);
      btn.textContent = hasLink ? 'Open link' : 'Open link (add URL)';
      btn.disabled = !hasLink;
      btn.setAttribute('aria-disabled', hasLink ? 'false' : 'true');
    }

    function renderTaskEditor() {
      const task = app.selectedTaskId ? getTaskById(app.selectedTaskId) : null;
      const empty = qs('taskEmpty');
      const editor = qs('taskEditor');
      const contextLine = qs('taskContextLine');
      if (!task) {
        empty.style.display = 'block';
        editor.style.display = 'none';
        if (contextLine) contextLine.textContent = 'Context: no task selected.';
        syncOpenLinkButtonFromEditor();
        return;
      }

      empty.style.display = 'none';
      editor.style.display = 'grid';
      if (contextLine) contextLine.textContent = `Context: ${LANE_LABEL[task.status]} · P${task.priority} · ${task.owner || 'unassigned owner'}`;
      qs('taskTitle').value = task.title;
      qs('taskDescription').value = task.description;
      qs('taskStatus').value = task.status;
      qs('taskPriority').value = String(task.priority);
      qs('taskLink').value = task.link || '';
      qs('taskOwner').value = task.owner || '';
      qs('taskDoD').value = task.definitionOfDone.join('\n');
      syncOpenLinkButtonFromEditor();
    }

    function buildExecutionBrief() {
      const now = sortedTasks('now').slice(0, 5);
      const next = sortedTasks('next').slice(0, 4);
      const blocked = sortedTasks('blocked').slice(0, 4);

      const fmt = (arr) => arr.length
        ? arr.map((t, i) => `${i + 1}. ${t.title} (P${t.priority}${t.owner ? ` · ${t.owner}` : ''})`).join('\n')
        : 'None';

      const owners = [...new Set(now.concat(blocked).map((t) => t.owner).filter(Boolean))];
      const linkTasks = now.concat(blocked).filter((t) => t.link).slice(0, 6);

      const mode = blocked.length
        ? 'blocked'
        : now.length
          ? 'executing'
          : next.length
            ? 'ready'
            : 'setup';

      return [
        'Mission Control — execution brief',
        `Generated: ${new Date().toLocaleString()}`,
        `Board mode: ${mode}`,
        `Lane counts: Now ${now.length} | Next ${next.length} | Blocked ${blocked.length} | Done ${sortedTasks('done').length}`,
        '',
        'Do now:',
        fmt(now),
        '',
        'Queue next:',
        fmt(next),
        '',
        'Blockers to clear first:',
        blocked.length ? blocked.map((t, i) => `${i + 1}. ${t.title} -> ${t.description || 'add concrete unblock action'}`).join('\n') : 'None',
        '',
        'Active owners:',
        owners.length ? owners.map((o, i) => `${i + 1}. ${o}`).join('\n') : 'None assigned',
        '',
        'Fast links:',
        linkTasks.length ? linkTasks.map((t, i) => `${i + 1}. ${t.title}: ${t.link}`).join('\n') : 'None',
        '',
        'Required report format:',
        '- shipped changes',
        '- validation evidence',
        '- blockers that remain',
        '- exact next action',
      ].join('\n');
    }

    function renderPrompt() {
      qs('prompt').textContent = buildExecutionBrief();
    }

    function renderCriteria() {
      const checks = app.criteriaChecks || {};
      const total = app.state.validationCriteria.length;
      const done = app.state.validationCriteria.reduce((acc, _, idx) => acc + (checks[idx] ? 1 : 0), 0);

      qs('criteria').innerHTML = app.state.validationCriteria.map((c, idx) => {
        const checked = checks[idx] ? 'checked' : '';
        return `<label><input type="checkbox" data-criteria-index="${idx}" ${checked}/> ${escapeHtml(c)}</label>`;
      }).join('') + `<div class="muted">Checklist progress: ${done}/${total} complete.</div>`;

      qs('criteria').querySelectorAll('input[type="checkbox"][data-criteria-index]').forEach((input) => {
        input.addEventListener('change', () => {
          const idx = Number(input.getAttribute('data-criteria-index'));
          if (!Number.isFinite(idx)) return;
          app.criteriaChecks[idx] = input.checked;
          persistCriteriaState();
          const updatedDone = app.state.validationCriteria.reduce((acc, _, i) => acc + (app.criteriaChecks[i] ? 1 : 0), 0);
          flashAction(`Checklist updated (${updatedDone}/${total}).`, 'info');
          renderCriteria();
        });
      });
    }

    function renderHeartbeat() {
      const blockers = sortedTasks('blocked');
      const topBlocker = blockers[0];
      const summary = [
        `Loop standard: ${app.heartbeatChecklist.length} checks every heartbeat.`,
        topBlocker ? `Top blocker: ${topBlocker.title}. Next action: ${topBlocker.description || 'Define unblock step.'}` : 'No blockers. Move next item from queue into Now.',
      ].join(' ');
      qs('heartbeatSummary').textContent = summary;
    }

    function renderFeed() {
      const feed = app.state.feed.slice().reverse();
      qs('feed').innerHTML = feed.length
        ? feed.map((f) => `<div class="feed-item"><div>${escapeHtml(f.text)}</div><div class="meta">${escapeHtml(f.time)} · ${escapeHtml(formatAge(f.ts))} · ${escapeHtml(f.level)}</div></div>`).join('')
        : '<div class="empty">No updates yet.</div>';
    }

    function buildStrikeBrief() {
      const now = sortedTasks('now').slice(0, 3).map((t, i) => `${i + 1}. ${t.title}`).join('\n') || 'None';
      const blocked = sortedTasks('blocked').slice(0, 2).map((t, i) => `${i + 1}. ${t.title}`).join('\n') || 'None';
      const notes = app.state.strikeDesk.notes.length
        ? app.state.strikeDesk.notes.slice(-4).map((n, i) => `${i + 1}. ${n}`).join('\n')
        : 'None';

      return [
        'Strike Brief — operator snapshot',
        '',
        `Policy: ${app.state.strikeDesk.policy}`,
        '',
        'Top Now:',
        now,
        '',
        'Current Blockers:',
        blocked,
        '',
        'Recent Strike notes:',
        notes,
      ].join('\n');
    }

    function renderStrikeDesk() {
      const desk = app.state.strikeDesk || normalizeStrikeDesk();
      qs('strikePolicy').textContent = desk.policy;
      qs('strikeFocus').innerHTML = desk.focus.length
        ? desk.focus.map((item) => `<li>${escapeHtml(item)}</li>`).join('')
        : '<li>No focus items yet.</li>';;
      qs('strikeNotes').innerHTML = desk.notes.length
        ? desk.notes.slice().reverse().map((n) => `<div class="feed-item">${escapeHtml(n)}</div>`).join('')
        : '<div class="empty">No strike notes yet.</div>';;
    }

    function flashAction(text, level = 'info') {
      const notice = qs('actionNotice');
      if (!notice) return;
      notice.textContent = text;
      notice.dataset.level = level;
      if (app.actionNoticeTimer) clearTimeout(app.actionNoticeTimer);
      app.actionNoticeTimer = setTimeout(() => {
        notice.textContent = 'Ready.';
        notice.dataset.level = 'info';
      }, 1800);
    }

    function hasUnsavedTaskChanges() {
      const task = getTaskById(app.selectedTaskId);
      const editorVisible = qs('taskEditor')?.style.display === 'grid';
      if (!task || !editorVisible) return false;

      const currentTitle = (qs('taskTitle')?.value || '').trim() || 'Untitled task';
      const currentDescription = (qs('taskDescription')?.value || '').trim();
      const currentStatus = qs('taskStatus')?.value || 'next';
      const currentPriority = Math.max(1, Math.min(99, Number(qs('taskPriority')?.value) || 5));
      const currentLink = (qs('taskLink')?.value || '').trim();
      const currentOwner = (qs('taskOwner')?.value || '').trim();
      const currentDoD = (qs('taskDoD')?.value || '').split('\n').map((s) => s.trim()).filter(Boolean);

      if (currentTitle !== task.title) return true;
      if (currentDescription !== task.description) return true;
      if (currentStatus !== task.status) return true;
      if (currentPriority !== task.priority) return true;
      if (currentLink !== task.link) return true;
      if (currentOwner !== task.owner) return true;
      if (JSON.stringify(currentDoD) !== JSON.stringify(task.definitionOfDone || [])) return true;
      return false;
    }

    function render() {
      renderStats();
      renderBoard();
      renderTaskEditor();
      renderPrompt();
      renderCriteria();
      renderHeartbeat();
      renderStrikeDesk();
      renderFeed();
    }

    function flashLane(status) {
      const lane = document.querySelector(`.lane[data-lane="${status}"]`);
      if (!lane) return;
      lane.classList.remove('flash');
      requestAnimationFrame(() => {
        lane.classList.add('flash');
        setTimeout(() => lane.classList.remove('flash'), 420);
      });
    }

    function moveSelectedTask(status) {
      const task = getTaskById(app.selectedTaskId);
      if (!task) {
        flashAction('Select a task first.', 'warn');
        return false;
      }
      if (!LANES.includes(status)) return false;
      if (task.status === status) {
        flashAction(`Task already in ${LANE_LABEL[status]}.`, 'info');
        return false;
      }
      task.status = status;
      addFeed(`Task moved to ${LANE_LABEL[status]}: ${task.title}`, 'change');
      persist();
      render();
      flashLane(status);
      flashAction(`Moved task to ${LANE_LABEL[status]}.`, 'ok');
      return true;
    }

    function focusTaskById(taskId, label = 'task') {
      const task = getTaskById(taskId);
      if (!task) {
        flashAction('Task no longer exists. Refresh view.', 'warn');
        return false;
      }
      app.selectedTaskId = task.id;
      render();
      jumpToTaskDetails();
      flashAction(`Focused ${label}: ${task.title}.`, 'ok');
      return true;
    }

    function focusTopTask(status) {
      const top = sortedTasks(status)[0];
      if (!top) {
        flashAction(`No tasks in ${LANE_LABEL[status]} lane.`, 'warn');
        return;
      }
      focusTaskById(top.id, `top ${LANE_LABEL[status]}`);
    }

    function focusFirstAction() {
      const candidate = sortedTasks('now')[0] || sortedTasks('blocked')[0] || sortedTasks('next')[0] || null;
      if (!candidate) {
        flashAction('No tasks available. Add a task to start.', 'warn');
        return;
      }
      focusTaskById(candidate.id, 'first action');
    }

    function saveCurrentTask() {
      const task = getTaskById(app.selectedTaskId);
      if (!task) return;
      const previousStatus = task.status;
      task.title = qs('taskTitle').value.trim() || 'Untitled task';
      task.description = qs('taskDescription').value.trim();
      task.status = qs('taskStatus').value;
      task.priority = Math.max(1, Math.min(99, Number(qs('taskPriority').value) || 5));
      task.link = qs('taskLink').value.trim();
      task.owner = qs('taskOwner').value.trim();
      task.definitionOfDone = qs('taskDoD').value.split('\n').map((s) => s.trim()).filter(Boolean);
      addFeed('Task updated: ' + task.title, 'change');
      persist();
      render();
      flashLane(task.status);
      if (previousStatus !== task.status) {
        flashAction(`Saved and moved task to ${LANE_LABEL[task.status]}.`, 'ok');
      } else {
        flashAction('Task saved.', 'ok');
      }
    }

    function addFeed(text, level = 'info') {
      app.state.feed.push(normalizeFeed({ text, level }));
      app.state.feed = app.state.feed.slice(-30);
    }

    function downloadJson(filename, data) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function escapeHtml(input) {
      return String(input)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function updateNextStepButton(sectionId) {
      const btn = qs('nextStepBtn');
      if (!btn) return;
      const idx = SECTION_ORDER.indexOf(sectionId);
      const safeIdx = idx >= 0 ? idx : 0;
      const nextIdx = (safeIdx + 1) % SECTION_ORDER.length;
      const nextId = SECTION_ORDER[nextIdx];
      btn.dataset.targetSection = nextId;
      btn.textContent = `Next step: ${SECTION_NAMES[nextId]}`;
    }

    function wireQuickNavTracking() {
      const links = Array.from(document.querySelectorAll('.quick-nav a[href^="#"]'));
      if (!links.length) return;

      const sections = links
        .map((link) => document.querySelector(link.getAttribute('href')))
        .filter(Boolean);

      const setActive = (sectionId) => {
        links.forEach((link) => {
          const href = link.getAttribute('href') || '';
          link.classList.toggle('active', href === `#${sectionId}`);
        });

        app.activeSectionId = sectionId;
        updateNextStepButton(sectionId);

        const idx = SECTION_ORDER.indexOf(sectionId);
        const step = idx >= 0 ? idx + 1 : '?';

        const whereAmI = qs('whereAmI');
        if (whereAmI) {
          const name = SECTION_NAMES[sectionId] || 'Current section';
          whereAmI.textContent = `You are in Step ${step} of 4: ${name}.`;
        }

        const stepGoalLine = qs('stepGoalLine');
        if (stepGoalLine) {
          stepGoalLine.textContent = SECTION_GOALS[sectionId] || 'Goal: keep execution moving.';
        }

        const stepActionLine = qs('stepActionLine');
        if (stepActionLine) {
          stepActionLine.textContent = SECTION_ACTIONS[sectionId] || 'Action: continue workflow.';
        }

        const stepProgressLine = qs('stepProgressLine');
        if (stepProgressLine) {
          const pct = Number.isFinite(step) ? Math.round((step / SECTION_ORDER.length) * 100) : 0;
          stepProgressLine.textContent = `Workflow progress: Step ${step}/${SECTION_ORDER.length} (${pct}%).`;
        }
      };

      links.forEach((link) => {
        link.addEventListener('click', (evt) => {
          if (evt.defaultPrevented) return;
          const id = (link.getAttribute('href') || '').replace('#', '');
          if (!id) return;
          setActive(id);
          const label = (link.textContent || '').replace(/^\s*\d+\)\s*/, '').trim();
          if (label) flashAction(`Jumped to ${label}.`, 'info');
        });
      });

      if ('IntersectionObserver' in window && sections.length) {
        const visibility = new Map();
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            visibility.set(entry.target.id, entry.isIntersecting ? entry.intersectionRatio : 0);
          });

          let bestId = null;
          let bestRatio = 0;
          visibility.forEach((ratio, id) => {
            if (ratio > bestRatio) {
              bestRatio = ratio;
              bestId = id;
            }
          });

          if (bestId) setActive(bestId);
        }, {
          root: null,
          rootMargin: '-15% 0px -55% 0px',
          threshold: [0.15, 0.35, 0.6]
        });

        sections.forEach((section) => observer.observe(section));
      }

      setActive('workboardSection');
    }

    function wireActions() {
      window.addEventListener('beforeunload', (evt) => {
        if (!hasUnsavedTaskChanges()) return;
        evt.preventDefault();
        evt.returnValue = '';
      });

      document.querySelectorAll('.quick-nav a').forEach((link) => {
        link.addEventListener('click', (evt) => {
          if (!hasUnsavedTaskChanges()) return;
          if (confirm('You have unsaved task edits. Continue without saving?')) return;
          evt.preventDefault();
        });
      });

      qs('nextStepBtn').addEventListener('click', () => {
        if (hasUnsavedTaskChanges() && !confirm('You have unsaved task edits. Continue without saving?')) {
          return;
        }

        const targetId = qs('nextStepBtn')?.dataset?.targetSection;
        if (!targetId) return;
        const target = document.getElementById(targetId);
        if (target && typeof target.scrollIntoView === 'function') {
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        const targetLink = document.querySelector(`.quick-nav a[href="#${targetId}"]`);
        if (targetLink && typeof targetLink.click === 'function') targetLink.click();
      });

      qs('openSelectedTaskBtn').addEventListener('click', () => {
        const selectedTask = app.selectedTaskId ? getTaskById(app.selectedTaskId) : null;
        if (!selectedTask) {
          flashAction('No task selected yet. Choose a card first.', 'warn');
          return;
        }
        jumpToTaskDetails();
        flashAction(`Opened selected task details: ${selectedTask.title}.`, 'info');
      });

      qs('addTaskBtn').addEventListener('click', () => {
        qs('taskModal').classList.add('show');
        flashAction('Create task modal opened.', 'info');
      });
      qs('createTaskCancelBtn').addEventListener('click', () => {
        qs('taskModal').classList.remove('show');
        flashAction('Task creation canceled.', 'info');
      });

      document.addEventListener('keydown', (evt) => {
        if (evt.key === 'Escape' && qs('taskModal').classList.contains('show')) {
          qs('taskModal').classList.remove('show');
          flashAction('Task creation canceled.', 'info');
          return;
        }

        const tag = (evt.target?.tagName || '').toUpperCase();
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;
        if (evt.metaKey || evt.ctrlKey || evt.altKey) return;

        const key = (evt.key || '').toLowerCase();
        if (key === 'n') {
          evt.preventDefault();
          qs('addTaskBtn').click();
          return;
        }
        if (key === 'f') {
          evt.preventDefault();
          qs('focusFirstActionBtn').click();
          return;
        }
        if (key === 'c') {
          evt.preventDefault();
          qs('copyPromptBtn').click();
        }
      });

      qs('createTaskConfirmBtn').addEventListener('click', () => {
        const title = qs('newTaskTitle').value.trim();
        if (!title) return;
        const task = normalizeTask({
          title,
          description: qs('newTaskDescription').value.trim(),
          status: qs('newTaskStatus').value,
          priority: Number(qs('newTaskPriority').value) || 5,
        });
        app.state.tasks.push(task);
        app.selectedTaskId = task.id;
        addFeed('Task created: ' + task.title, 'change');
        persist();
        qs('taskModal').classList.remove('show');
        flashAction('Task created and selected.', 'ok');
        qs('newTaskTitle').value = '';
        qs('newTaskDescription').value = '';
        render();
      });

      qs('saveTaskBtn').addEventListener('click', () => {
        saveCurrentTask();
      });
      qs('taskLink').addEventListener('input', () => {
        syncOpenLinkButtonFromEditor();
      });

      qs('moveNowBtn').addEventListener('click', () => moveSelectedTask('now'));
      qs('moveNextBtn').addEventListener('click', () => moveSelectedTask('next'));
      qs('moveBlockedBtn').addEventListener('click', () => moveSelectedTask('blocked'));
      qs('moveDoneBtn').addEventListener('click', () => moveSelectedTask('done'));

      qs('focusFirstActionBtn').addEventListener('click', () => focusFirstAction());
      qs('focusNowBtn').addEventListener('click', () => focusTopTask('now'));
      qs('focusBlockedBtn').addEventListener('click', () => focusTopTask('blocked'));
      qs('focusNextBtn').addEventListener('click', () => focusTopTask('next'));
      qs('pathNowBtn').addEventListener('click', () => {
        const id = qs('pathNowBtn')?.dataset?.taskId;
        if (id) focusTaskById(id, 'Now path');
      });
      qs('pathBlockedBtn').addEventListener('click', () => {
        const id = qs('pathBlockedBtn')?.dataset?.taskId;
        if (id) focusTaskById(id, 'Blocked path');
      });
      qs('pathNextBtn').addEventListener('click', () => {
        const id = qs('pathNextBtn')?.dataset?.taskId;
        if (id) focusTaskById(id, 'Next path');
      });
      qs('recommendedActionBtn').addEventListener('click', () => {
        switch (app.recommendedAction) {
          case 'openFirst':
            qs('focusFirstActionBtn').click();
            break;
          case 'unblockTop':
            qs('unblockTopBtn').click();
            break;
          case 'pullTopNext':
            qs('pullNextBtn').click();
            break;
          default:
            qs('addTaskBtn').click();
            break;
        }
      });

      qs('deleteTaskBtn').addEventListener('click', () => {
        const task = getTaskById(app.selectedTaskId);
        if (!task) return;
        if (!confirm(`Delete task "${task.title}"?`)) return;
        app.state.tasks = app.state.tasks.filter((t) => t.id !== task.id);
        app.selectedTaskId = getDefaultTaskId();
        addFeed('Task deleted: ' + task.title, 'change');
        persist();
        render();
        flashAction('Task deleted.', 'ok');
      });

      qs('openTaskLinkBtn').addEventListener('click', () => {
        const task = getTaskById(app.selectedTaskId);
        if (!task) {
          flashAction('Select a task first.', 'warn');
          return;
        }
        const link = (task.link || '').trim();
        if (!link) {
          flashAction('Add a link in task details first.', 'warn');
          return;
        }
        window.open(link, '_blank', 'noopener');
        flashAction('Opened task link in a new tab.', 'ok');
      });

      qs('copyPromptBtn').addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(qs('prompt').textContent);
          qs('copyPromptBtn').textContent = 'Copied';
          setTimeout(() => qs('copyPromptBtn').textContent = '2) Copy brief', 1000);
          flashAction('Execution brief copied.', 'ok');
        } catch {
          qs('copyPromptBtn').textContent = 'Copy failed';
          setTimeout(() => qs('copyPromptBtn').textContent = '2) Copy brief', 1200);
          flashAction('Copy failed. Select the brief and press ⌘C.', 'warn');
        }
      });

      qs('exportBtn').addEventListener('click', () => {
        downloadJson('mission-control-board.json', app.state);
        flashAction('Board JSON exported.', 'ok');
      });

      qs('importBtn').addEventListener('click', () => {
        qs('importInput').click();
        flashAction('Select a JSON file to import.', 'info');
      });
      qs('importInput').addEventListener('change', async (evt) => {
        const file = evt.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const parsed = JSON.parse(text);
          app.state = createDefaultState(parsed);
          app.selectedTaskId = getDefaultTaskId();
          addFeed('Board imported from JSON', 'change');
          persist();
          render();
          flashAction('Board imported from JSON.', 'ok');
        } catch {
          flashAction('Import failed: use a valid board JSON export.', 'warn');
          addFeed('Import failed: invalid JSON file format', 'warn');
          renderFeed();
        }
      });

      qs('resetBtn').addEventListener('click', () => {
        if (!confirm('Reset board to baseline state.json?')) return;
        app.state = createDefaultState(app.baseline);
        app.selectedTaskId = getDefaultTaskId();
        addFeed('Board reset to baseline', 'change');
        persist();
        render();
        flashAction('Board reset to baseline.', 'ok');
      });

      qs('pullNextBtn').addEventListener('click', () => {
        const nextTask = sortedTasks('next')[0];
        if (!nextTask) {
          flashAction('No tasks in Next lane.', 'warn');
          return;
        }
        app.selectedTaskId = nextTask.id;
        moveSelectedTask('now');
      });

      qs('unblockTopBtn').addEventListener('click', () => {
        const blockedTask = sortedTasks('blocked')[0];
        if (!blockedTask) {
          flashAction('No tasks in Blocked lane.', 'warn');
          return;
        }
        app.selectedTaskId = blockedTask.id;
        moveSelectedTask('next');
      });

      qs('completeTopNowBtn').addEventListener('click', () => {
        const nowTask = sortedTasks('now')[0];
        if (!nowTask) {
          flashAction('No tasks in Now lane.', 'warn');
          return;
        }
        app.selectedTaskId = nowTask.id;
        const moved = moveSelectedTask('done');
        if (!moved) return;

        if (sortedTasks('now').length === 0) {
          const nextTask = sortedTasks('next')[0];
          if (nextTask) {
            app.selectedTaskId = nextTask.id;
            moveSelectedTask('now');
            flashAction(`Completed and pulled next task: ${nextTask.title}`, 'ok');
          }
        }
      });

      qs('strikeNoteAddBtn').addEventListener('click', () => {
        const note = qs('strikeNoteInput').value.trim();
        if (!note) return;
        app.state.strikeDesk.notes.push(note);
        app.state.strikeDesk.notes = app.state.strikeDesk.notes.slice(-20);
        qs('strikeNoteInput').value = '';
        persist();
        render();
        flashAction('Strike note added.', 'ok');
      });

      qs('copyStrikeBriefBtn').addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(buildStrikeBrief());
          flashAction('Strike brief copied.', 'ok');
        } catch {
          flashAction('Strike brief copy failed. Select text and press ⌘C.', 'warn');
        }
      });

      qs('feedAddBtn').addEventListener('click', () => {
        const text = qs('feedInput').value.trim();
        if (!text) return;
        addFeed(text, 'note');
        qs('feedInput').value = '';
        persist();
        render();
        flashAction('Feed update added.', 'ok');
      });
    }

    async function init() {
      nowClock();
      setInterval(nowClock, 1000);

      app.baseline = await loadBaseline();
      const baseState = createDefaultState(app.baseline);
      const persisted = loadPersisted();
      app.state = persisted ? createDefaultState(persisted) : baseState;
      app.selectedTaskId = getDefaultTaskId();
      app.criteriaChecks = loadCriteriaState();

      wireActions();
      wireQuickNavTracking();
      render();
    }

    init();
  </script>
</body>
</html>
